var documenterSearchIndex = {"docs":
[{"location":"#AutoVectors.jl-Documentation","page":"AutoVectors.jl Documentation","title":"AutoVectors.jl Documentation","text":"","category":"section"},{"location":"","page":"AutoVectors.jl Documentation","title":"AutoVectors.jl Documentation","text":"","category":"page"},{"location":"#Constructors","page":"AutoVectors.jl Documentation","title":"Constructors","text":"","category":"section"},{"location":"","page":"AutoVectors.jl Documentation","title":"AutoVectors.jl Documentation","text":"AutoVector(0.0)\nmakeauto(v::Vector;offset=nothing, firstindex=nothing, cutoff=0.0)\nmakeAutoVectorOfVecs(veczero::Vector,mini::Integer,maxi::Integer)","category":"page"},{"location":"#AutoVectors.AutoVector-Tuple{Any}","page":"AutoVectors.jl Documentation","title":"AutoVectors.AutoVector","text":"AutoVector(def=0.0,mini::Integer=1,maxi::Integer=0,miniloc::Integer=0)\nAutoVector(f::Function,mini::Integer=1,maxi::Integer=0,miniloc::Integer=0)\nAutoVector(v::Vector,mini::Integer=1,maxi::Integer=0,miniloc::Integer=0)\n\nFrequently you just use\n\nv = AutoVector(), defaulting to Float64, size 0\n\nor     v = AutoVector(0), defaulting to Int64, size 0\n\nAn AutoVector expands when written to outside its range. Reading outside its range  does not expand the range, and gives def.\n\nArguments:\n\ndefâ€“default element, usually 0.0. Determines the type T of AutoVector{T}\n\nmini and maxi give the index range of the created AutoVector (logical indices, not index in data vector)\n\nminiloc is the location of mini-1 within the data vector, default 0 (data index)\n\nYou can initialize an AutoVector with the default, from a function, or by putting in a vector. Most functions and constructors deal with logical indices, Data indices refers to location within the data vector dat, which should not be something to worry about normally.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.makeauto-Tuple{Vector{T} where T}","page":"AutoVectors.jl Documentation","title":"AutoVectors.makeauto","text":"makeauto(v::Vector{T};offset=nothing, firstindex=nothing, cutoff=0.0) where T\n\nMake an AutoVector out of a Vector, producing a new data vector. If offset is supplied, shifts data to left by offset. If firstindex is supplied, it makes mini=firstindex You can't specify both offset and firstindex. With cutoff nonzero, elements are only put in if abs(el) > cutoff To put in a part of a Vector at a particular range, say putting elements 2 to 4 at positions 5 to 7, do this: makeauto(v[2:4],firstindex=5)\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.makeAutoVectorOfVecs-Tuple{Vector{T} where T, Integer, Integer}","page":"AutoVectors.jl Documentation","title":"AutoVectors.makeAutoVectorOfVecs","text":"makeAutoVectorOfVecs(veczero::Vector,mini::Integer,maxi::Integer)\n\nCreate an AutoVector that holds Vectors as elements, an AutoVecotr of Vectors. The zero default Vector is veczero.\n\n\n\n\n\n","category":"method"},{"location":"#Functions","page":"AutoVectors.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"AutoVectors.jl Documentation","title":"AutoVectors.jl Documentation","text":"mini(v::AutoVector)\nmaxi(v::AutoVector)\nlength(v::AutoVector)\narange(v::AutoVector)\navvec(v::AutoVector)\nsubav(v::AutoVector,i::Integer,j::Integer)\navdot(x::AutoVector,y::AutoVector)\nconvolve(x::AutoVector,y::AutoVector,cut=1.0e-14) \ndoprint(v::AutoVector)\nfast(v::AutoVector,i)\nclear!(v::AutoVector)\navnorm(v::AutoVector)\navlocation(v::AutoVector,i)\navlocmin(v::AutoVector)\navlocmax(v::AutoVector)\navtriple(x::AutoVector,y::AutoVector,z::AutoVector)\naxpy!(y::AutoVector,a::Float64,x::AutoVector) \naxpy!(y::AutoVector,a::Float64,x::AutoVector, cutoff::Float64) \navtripconv(u::AutoVector,g::AutoVector,v::AutoVector)\napplyshift(x::AutoVector,offset::Integer)\nshrink!(x::AutoVector,cut)\nreverse_ind(x::AutoVector)\nfftav(x::AutoVector{Float64},delta)\nifftav(x::AutoVector{ComplexF64},freqspacing::Float64,len::Integer)\n","category":"page"},{"location":"#AutoVectors.mini-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.mini","text":"mini(v::AutoVector)\n\nMinimum logical index.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.maxi-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.maxi","text":"maxi(v::AutoVector)\n\nMaximum logical index.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"Base.length","text":"length(v::AutoVector)\n\nLogical length.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.arange-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.arange","text":"avrange(v::AutoVector)\n\nThe logical range as mini:maxi.  A synonym is arange.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avvec-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avvec","text":"avvec(v::AutoVector)\n\navvec(v) creates a standard Vector with all values from mini to maxi; the new Vector does not know mini; it only knows its length, given by maxi-mini+1.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.subav-Tuple{AutoVector, Integer, Integer}","page":"AutoVectors.jl Documentation","title":"AutoVectors.subav","text":"subav(x::AutoVector,newmini::Integer,newmaxi::Integer)\n\nCreate a new AutoVector with the indicated range, sharing the same data array\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avdot-Tuple{AutoVector, AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avdot","text":"avdot(x::AutoVector,y::AutoVector)\n\nDot product (with no complex conjugating), sumi xi y_i over the intersection of ranges.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.convolve","page":"AutoVectors.jl Documentation","title":"AutoVectors.convolve","text":"convolve(x::AutoVector,y::AutoVector,cut=1.0e-14)\t\t# use absolute cutoff\n\nConvolve with cutoff; no writing of elements if abs(value) < cut\n\n\n\n\n\n","category":"function"},{"location":"#AutoVectors.doprint-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.doprint","text":"doprint([file descriptor],v::AutoVector; spacing = 1)\n\nPrint all the elements to standard output or a file, with indices scaled by spacing.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.fast-Tuple{AutoVector, Any}","page":"AutoVectors.jl Documentation","title":"AutoVectors.fast","text":"fast(v::AutoVector,i)\n\nfast(v,i) is like accessing v[i], but without the check for being outside the logical range.  If i is outside, fast  may or may not throw a standard range exception depending on whether i lands outside the data vector's range. For use when i is known to be inside the logical range.  Combined with @inbounds, there will be no range checking at all, for optimal speed.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.clear!-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.clear!","text":"clear!(v::AutoVector)\n\nResets v to empty.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avnorm-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avnorm","text":"avnorm(v::AutoVector)\n\nNorm of AutoVector\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avlocation-Tuple{AutoVector, Any}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avlocation","text":"avlocation(v::AutoVector,i)\n\nThe data location of logical index i.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avlocmin-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avlocmin","text":"avlocmin(v::AutoVector)\n\nThe data location of mini(v).\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avlocmax-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avlocmax","text":"avlocmax(v::AutoVector)\n\nThe data location of maxi(v).\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avtriple-Tuple{AutoVector, AutoVector, AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avtriple","text":"avtriple(x::AutoVector,y::AutoVector,z::AutoVector)\n\nTriple dot product (with no complex conjugating), sumi xi yi zi over the intersection of ranges.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.axpy!-Tuple{AutoVector, Float64, AutoVector}","page":"AutoVectors.jl Documentation","title":"LinearAlgebra.axpy!","text":"axpy!(y::AutoVector,a::Float64,x::AutoVector)\t# y += a * x\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.axpy!-Tuple{AutoVector, Float64, AutoVector, Float64}","page":"AutoVectors.jl Documentation","title":"LinearAlgebra.axpy!","text":"axpy!(y::AutoVector,a::Float64,x::AutoVector, cutoff::Float64)\t# y += a * x with cutoff for writing\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.avtripconv-Tuple{AutoVector, AutoVector, AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.avtripconv","text":"avtripconv(u::AutoVector,g::AutoVector,v::AutoVector)\n\nSame as avdot(convolve(u,g),v)\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.applyshift-Tuple{AutoVector, Integer}","page":"AutoVectors.jl Documentation","title":"AutoVectors.applyshift","text":"applyshift(x::AutoVector,offset::Integer)\n\nCreate a new AutoVector shifted to left by offset, sharing the same data array.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.shrink!-Tuple{AutoVector, Any}","page":"AutoVectors.jl Documentation","title":"AutoVectors.shrink!","text":"shrink!(x::AutoVector,cut)\n\nAdjust mini and maxi to omit tails where all elements are less than cut in absolute value.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.reverse_ind-Tuple{AutoVector}","page":"AutoVectors.jl Documentation","title":"AutoVectors.reverse_ind","text":"reverse_ind(x::AutoVector)\n\nA reflection about the origin; the new AutoVector goes from -maxi to -mini.\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.fftav-Tuple{AutoVector{Float64}, Any}","page":"AutoVectors.jl Documentation","title":"AutoVectors.fftav","text":"fftav(f::AutoVector{Float64},delta)\n\nFor a function f_i defined on a uniform grid with spacing delta, returns the Fourier Transform and frequency spacing, and the length of the vector used in the FFT (to be used in ifftav).  The output AutoVector will be complex. The FT is defined as\n\nF(omega) = frac1sqrt2 pi int dx e^-i k x f(x)\n\n\n\n\n\n","category":"method"},{"location":"#AutoVectors.ifftav-Tuple{AutoVector{ComplexF64}, Float64, Integer}","page":"AutoVectors.jl Documentation","title":"AutoVectors.ifftav","text":"ifftav(F::AutoVector{ComplexF64},freqspacing,maxind)\n\nFor a function F_i defined on a uniform frequency grid with spacing freqspacing,  returns the Inverse Fourier Transform.\n\nf(omega) = frac1sqrt2 pi int dk e^i k x F(k)\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"AutoVectors.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"AutoVectors.jl Documentation","title":"AutoVectors.jl Documentation","text":"","category":"page"}]
}
